import glob
import re

###############
# Input
###############
chip_fastqs_path = config["input"]["ChIP_fastqs"]
control_fastqs_path = config["input"]["Control_fastqs"]

###############
# Parameters
###############
index = config["input"]["bowtie_index"]
process = config["common_params"]["processes"]
include_spikein = config["common_params"]["include_spikein"]
index_primary = config["spikein_params"]["index_primary"]
index_spikein = config["spikein_params"]["index_spikein"]
binsize = config["spikein_params"]["binsize"]

quality = config["samtools_params"]["quality"]
distance = config["samtools_params"]["distance"]

no_model  = config["macs2_params"]["no_model"]
if no_model:
    nomodel_option = "--nomodel"
else:
    nomodel_option = ""

###############
# Output path
###############
ChIP_result_folder = config["output"]["ChIP_output_path"]
Control_result_folder = config["output"]["Control_output_path"]

########################
# Some condition check
########################
if include_spikein:
    if index_spikein == "" or index_spikein == None:
        raise ValueError("if you include spikein procedure, then index_spikein need to be spcified")

if index_spikein != "" and index_spikein != None:
    if not include_spikein:
        raise ValueError("Since index_spikein is spcified, <include_spikein> parameter should be set to true")


#############################################
# Create lists of output filenames
#############################################
sample_filenames = glob.glob(chip_fastqs_path+'/*.fastq*')
pattern = r"(_[12])?\.fastq.*"
samples = [re.sub(pattern, '', s.split('/')[-1]) for s in sample_filenames]
samples = list(set(samples))

sam = expand(
        f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.sam",
        sample_name=samples
    )

bam = expand(
        f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.bam",
        sample_name=samples
    )
fixed_bam = expand(
        f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.fixed.bam",
        sample_name=samples
    )

fixed_sort_bam = expand(
        f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.fixed.sort.bam",
        sample_name=samples
    )

dedup_sam = expand(
        f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.dedup.sam",
        sample_name=samples
    )
if include_spikein:
    sam_stats = expand(
            f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.spikein.stats",
            sample_name=samples
        )

    primary_sort_bam = expand(
            f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_primary}.sort.bam",
            sample_name=samples
        )

    spikein_sort_bam = expand(
            f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_spikein}.sort.bam",
            sample_name=samples
        )
    # bw = expand(
    #             f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.rescale.bw",
    #             sample_name=samples
    #         )
    if control_fastqs_path == '' :
        bw = expand(
            f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.bw",
            sample_name=samples
        )
    else:
        bw = expand(
                f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.rescale.bw",
                sample_name=samples
            )
    peaks_bed = expand(
            f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_primary}.sort_summits.bed",
            sample_name=samples
        )
else:
    sam_stats = []
    primary_sort_bam = []
    spikein_sort_bam = []
    index_primary = "no_primary"
    index_spikein = "no_spikein"
    bw = expand(
            f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.bw",
            sample_name=samples
        )
    peaks_bed = expand(
            f"{ChIP_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.fixed.sort_summits.bed",
            sample_name=samples
        )

# Control output files
if control_fastqs_path == '' :
    ctrl_sam = []
    ctrl_bam = []
    ctrl_fixed_bam = []
    ctrl_fixed_sort_bam = []
    ctrl_dedup_sam = []
    ctrl_sam_stats = []
    ctrl_primary_sort_bam = []
    ctrl_spikein_sort_bam = []
else:
    sample_filenames = glob.glob(control_fastqs_path+'/*.fastq*')
    pattern = r"(_[12])?\.fastq.*"
    samples = [re.sub(pattern, '', s.split('/')[-1]) for s in sample_filenames]
    ctrl_sam = expand(
            f"{Control_result_folder}/{{sample_name}}/{{sample_name}}.sam",
            sample_name=samples
        )

    ctrl_bam = expand(
            f"{Control_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.bam",
            sample_name=samples
        )
    ctrl_fixed_bam = expand(
            f"{Control_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.fixed.bam",
            sample_name=samples
        )

    ctrl_fixed_sort_bam = expand(
            f"{Control_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.fixed.sort.bam",
            sample_name=samples
        )

    ctrl_dedup_sam = expand(
            f"{Control_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.dedup.sam",
            sample_name=samples
        )

    if include_spikein:
        ctrl_sam_stats = expand(
                f"{Control_result_folder}/{{sample_name}}/{{sample_name}}.spikein.stats",
                sample_name=samples
            )

        ctrl_primary_sort_bam = expand(
                f"{Control_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_primary}.sort.bam",
                sample_name=samples
            )

        ctrl_spikein_sort_bam = expand(
                f"{Control_result_folder}/{{sample_name}}/{{sample_name}}.q{quality}.{index_spikein}.sort.bam",
                sample_name=samples
            )
    else:
        ctrl_sam_stats = []
        ctrl_primary_sort_bam = []
        ctrl_spikein_sort_bam = []


rule all:
    input:
        sam,
        ctrl_sam,
        bam,
        ctrl_bam,
        fixed_bam,
        ctrl_fixed_bam,
        fixed_sort_bam,
        ctrl_fixed_sort_bam,
        dedup_sam,
        ctrl_dedup_sam,
        sam_stats,
        ctrl_sam_stats,
        primary_sort_bam,
        ctrl_primary_sort_bam,
        spikein_sort_bam,
        ctrl_spikein_sort_bam,
        bw,
        peaks_bed,

def get_input(wildcards):
    plain = f"{chip_fastqs_path}/{wildcards.sample}.fastq"
    gzipped = f"{chip_fastqs_path}/{wildcards.sample}.fastq.gz"
    paired1 = f"{chip_fastqs_path}/{wildcards.sample}_1.fastq"
    paired2 = f"{chip_fastqs_path}/{wildcards.sample}_2.fastq"

    if os.path.exists(plain):
        return plain
    elif os.path.exists(gzipped):
        return gzipped
    elif os.path.exists(paired1):
        return [paired1, paired2]

    raise FileNotFoundError(f"No input file found for sample {wildcards.sample}, here's the path{gzipped}, {wildcards.sample}")

##############################
# Alignment starts here
##############################
rule bowtie2_map:
    input:
        files = get_input
    conda:
        "envs/fasta_frip_env.yml"
    wildcard_constraints:
        sample = "[a-zA-Z0-9_-]+"
    output:
        f"{{maps}}/{{sample_name}}/{{sample}}.sam"
    shell:
        """
        files=({input.files})
        num_files=${{#files[@]}}

        if [ "$num_files" -eq 1 ]; then
            bowtie2 -p {process} -x {index} -U {input.files} -S {output}
        elif [ "$num_files" -eq 2 ]; then
            bowtie2 -p {process} -x {index} -1 {input.files[0]} -2 {input.files[1]}  -S {output}
        fi
        """

rule samtools_filter:
    input:
        f"{{maps}}/{{sample_name}}/{{sample}}.sam"
    conda:
        "envs/fasta_frip_env.yml"
    output:
        temp(f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.bam")
    shell:
        "samtools view --threads {process} -h -q {quality} {input} > {output}"

rule samtools_fixmate:
    input:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.bam"
    params:
        sorted_name = f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.sorted.bam"
    conda:
        "envs/fasta_frip_env.yml"
    output:
        temp(f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.fixed.bam")
    shell:
        """
        samtools sort -n -@{process} {input} -o {params.sorted_name}
        samtools fixmate -m -r {params.sorted_name} {output}
        rm {params.sorted_name}
        """

rule samtools_sort:
    input:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.fixed.bam"
    conda:
        "envs/fasta_frip_env.yml"
    output:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.fixed.sort.bam"
    shell:
        """
        samtools sort -@{process} {input} -o {output}
        samtools index --threads {process} {output}
        """

rule samtools_markdup:
    input:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.fixed.sort.bam"
    params:
        stats_file_path = f"{{maps}}/{{sample_name}}/{{sample}}.markdup.stats"
    conda:
        "envs/fasta_frip_env.yml"
    output:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.dedup.sam"
    shell:
        "samtools markdup -f {params.stats_file_path} -r -d {distance} {input} {output}"

rule bw:
    input:
        f"{ChIP_result_folder}/{{sample_name}}/{{sample}}.q{quality}.fixed.sort.bam"
    conda:
        "envs/fasta_frip_env.yml"
    output:
        f"{ChIP_result_folder}/{{sample_name}}/{{sample}}.bw"
    shell:
        "bamCoverage -b {input} -o {output} -of bigwig --binSize {binsize}"


############################################################
# The following procedure is for Spike-in ChIP protocol
############################################################
# Count the number of reads that map to each genome and print the ratio
rule spikein_stats:
    input:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.dedup.sam"
    conda:
        "envs/fasta_frip_env.yml"
    output:
        f"{{maps}}/{{sample_name}}/{{sample}}.spikein.stats"
    shell:
        """
        primary_reads=$(( `grep -c '.*{index_primary}.*' {input}` - 22 )) 
        spikein_reads=$(( `grep -c '.*{index_spikein}.*' {input}` - 26 )) 
        echo -e "{index_primary}_reads=$primary_reads" >> {output} 
        echo "{index_spikein}_reads=$spikein_reads" >> {output} 
        echo "ratio of {index_primary} to {index_spikein} reads is" >> {output} 
        echo "scale=2; $primary_reads/$spikein_reads" | bc >> {output} 
        """

# Use grep to create a sam file with only the mm reads
rule separate_reads:
    input:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.dedup.sam"
    params:
        primary_sam_tmp = f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.{index_primary}.sam",
        spikein_sam_tmp = f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.{index_spikein}.sam",
    conda:
        "envs/fasta_frip_env.yml"
    output:
        output1 = f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.{index_primary}.sort.bam",
        output2 = f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.{index_spikein}.sort.bam"
    shell:
        """
        grep -v '.*{index_spikein}.*' {input} > {params.primary_sam_tmp}
        sed -i 's/{index_primary}_chr/chr/' {params.primary_sam_tmp}
        samtools sort {params.primary_sam_tmp} -o {output.output1}
        rm {params.primary_sam_tmp}
        samtools index --threads {process} {output.output1}

        grep -v '.*{index_primary}.*' {input} > {params.spikein_sam_tmp}
        sed -i 's/{index_spikein}_chr/chr/' {params.spikein_sam_tmp}
        samtools sort {params.spikein_sam_tmp} -o {output.output2}
        rm {params.spikein_sam_tmp}
        samtools index --threads {process} {output.output2}
        """

# Spike-in Normalization
rule rescaling:
    input:
        ChIP_stats = f"{ChIP_result_folder}/{{sample_name}}/{{sample}}.spikein.stats",
        ctrl_stats = f"{Control_result_folder}/{{sample_name}}/{{sample}}.spikein.stats",
        ChIP_bam = f"{ChIP_result_folder}/{{sample_name}}/{{sample}}.q{quality}.{index_primary}.sort.bam"
    conda:
        "envs/fasta_frip_env.yml"
    output:
        f"{ChIP_result_folder}/{{sample_name}}/{{sample}}.rescale.bw"
    shell:
        """
        primary_reads=$(awk -F'=' '/{index_primary}_reads/{{print $2}}' {input.ChIP_stats}) 
        spikein_reads=$(awk -F'=' '/{index_spikein}_reads/{{print $2}}' {input.ChIP_stats}) 
        ctrl_primary_reads=$(awk -F'=' '/{index_primary}_reads/{{print $2}}' {input.ctrl_stats})  
        ctrl_spikein_reads=$(awk -F'=' '/{index_spikein}_reads/{{print $2}}' {input.ctrl_stats})
        factor=`echo "scale=20; $ctrl_spikein_reads / $ctrl_primary_reads / $spikein_reads * 15000000" | bc`
        echo "Scaling_factor=$factor" >> {input.ChIP_stats}
        bamCoverage -b {input.ChIP_bam} -o {output} -of bigwig --binSize {binsize} --scaleFactor $factor
        """

##############################
# Calling peaks
##############################
rule bam_to_bed:
    input:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.{{type}}.sort.bam"
    params:
        output_prefix = f"{{sample}}.q{quality}.{{type}}.sort", 
        output_dir = f"{{maps}}/{{sample_name}}/"
    conda:
        "envs/fasta_frip_env.yml"
    output:
        f"{{maps}}/{{sample_name}}/{{sample}}.q{quality}.{{type}}.sort_summits.bed"
    shell:
        "macs2 callpeak {nomodel_option} -t {input} -n {params.output_prefix} --outdir {params.output_dir}"